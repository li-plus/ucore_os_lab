# Report for Lab 7

## 练习 1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

**给出内核级信号量的设计描述，并说明其大致执行流程**

内核级信号量在`sem.h`中定义，对应的数据结构为`semaphore_t`，包含一个整数值以及一个等待队列。信号量机制实现在`sem.c`内，主要实现了以下函数，

+ `sem_init`: 初始化信号量的值和等待队列。
+ `up`: 相当于V操作，如果等待队列为空，则增加信号量的值，否则，唤醒等待队列的队首进程，使其状态变成`RUNNABLE`。全过程需要关闭中断，从而保证操作的原子性。
+ `down`: 相当于P操作，如果信号量大于零，则令信号量减一并正常返回，否则，将当前进程加入等待队列，设置其状态为`SLEEPING`，并重新调度，直到该进程被唤醒，才继续执行，此时将进程移出等待队列并返回。同样需要保证信号量读写的原子性。
+ `try_down`: 如果信号量大于零，减一并返回成功标志，否则，返回失败标志。同样需要保证信号量读写的原子性。

大致执行流程如下，

+ init进程执行时，在`init_main`中会调用`check_sync`，检查哲学家问题，包括基于信号量实现的版本，以及基于条件变量的版本，这里只考虑信号量的版本。
+ 接下来创建若干个进程，每个进程代表一个哲学家，每个哲学家思考若干次，每次思考一段时间，然后试图拿起左右两把叉子，进餐一段时间，就餐完放下左右两把叉子，然后进行下一次思考。
+ 试图拿起左右两把叉子时，首先加互斥锁`mutex`，将自身置为饥饿状态，若左右邻居都不在进餐则增加信号量`s[i]`，然后释放互斥锁，并试图减少`s[i]`。显然，如果两人都不在进餐，则成功获得两把叉子，如果至少一人在进餐，则阻塞等待信号量`s[i]`。
+ 放下左右两把叉子时，首先加互斥锁`mutex`，将自身置为思考状态，测试一下当自己放下叉子时，左右邻居能否进餐，如果可以，则增加他们的信号量，唤醒他们进餐。

**给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同**

对于用户态进程，操作系统需要维护每个进程的信号量，并通过一组系统调用为用户提供`sem_init, up, down, try_down`四个接口，从而支持用户态的信号量机制。

相同点在于信号量均由操作系统维护，信号量操作均为原子操作。不同点在于用户态进程需要系统调用机制来操作信号量，而内核态进程可以直接访问。

## 练习 2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

**给出内核级条件变量的设计描述，并说明其大致执行流程**

内核级条件变量机制实现在`monitor.c`中，需要实现`signal`和`wait`两个方法，这里实现的是Hoare管程，具体设计如下，

```c
void 
cond_signal (condvar_t *cvp) {
    // 如果等待队列非空
    if (cvp->count > 0) {
        // 将自己加入next的等待队列中，计数加一
        cvp->owner->next_count++;
        // 唤醒等待的进程
        up(&(cvp->sem));
        // 由于是Hoare管程，因此自己阻塞等待，调度器将会切换到刚才被唤醒的进程
        down(&(cvp->owner->next));
        // 唤醒的进程返回后，恢复next等待队列的进程计数
        cvp->owner->next_count--;
    }
}

void
cond_wait (condvar_t *cvp) {
    // 将自己加入等待队列，计数加一
    cvp->count++;
    if (cvp->owner->next_count > 0) {
        // 如果有进程在next等待队列中等待，说明自己是被它唤醒的，现在唤醒它让它继续执行
        up(&(cvp->owner->next));
    } else {
        // 否则，唤醒其它等待的进程
        up(&(cvp->owner->mutex));
    }
    // 阻塞等待
    down(&(cvp->sem));
    // 被唤醒后，恢复等待队列进程计数
    cvp->count--;
}
```

大致执行流程与信号量版本基本一致，仅拿起叉子和放下叉子的过程略有不同，可以将它们称为管程，

+ 进入管程时，需要加互斥锁`mutex`，离开管程时，如果有进程在`next`队列中等待，则首先唤醒该进程，否则，放弃互斥锁`mutex`。
+ 试图拿起叉子时，若左右邻居都不在进餐，则成功获得叉子，否则，阻塞等待(`cond_wait`)条件变量`cv[i]`，由于是Hoare管程，因此等待结束后无需再次判断，可立即获得叉子。
+ 放下左右两把叉子时，测试一下当自己放下叉子时，左右邻居能否进餐，如果可以，则通知(`cond_signal`)他们进餐。

**给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同**

条件变量是通过信号量实现的，只要操作系统实现了用户态信号量机制，用户就可以进一步封装成条件变量的`wait`和`signal`方法，实现用户态的条件变量机制。

异同点分析详见信号量机制部分。

**能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。**

能。实现条件变量只需要一个等待队列和一个互斥锁，伪代码如下，

```c
typedef struct condvar {
    int num_waiting;
    wait_queue_t wq;
} condvar_t;

void cond_signal (condvar_t *cv) {
    if (cv->num_waiting > 0) {
        t = dequeue(cv->wq);
        wakeup(t); // need mutex
        cv->num_waiting--;
    }
}

void cond_wait (condvar_t *cv, mutex_t *lock) {
    cv->num_waiting++;
    enqueue(cv->wq, current);
    release(lock);
    schedule(); // need mutex
    require(lock);
}
```

## 我的实现与参考答案的区别

+ 练习2：基本一致

## 本实验对应的OS知识点

+ 练习1：同步互斥，信号量机制
+ 练习2：管程与条件变量，哲学家就餐问题

## 本实验未对应的OS知识点

+ Hansen管程
+ 生产者-消费者问题，读者-写者问题
